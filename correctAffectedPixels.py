#!/usr/bin/env python
# -*- coding: utf-8 -*-

# NOTE: Include license!!!
# Author: Viraja Khatu


# ---------------------------------------------------------------------------------------------------------------------
# Import required modules
import numpy as np
import statistics as stats
from random import gauss
from astropy.io import ascii
import matplotlib.pyplot as plt
from copy import deepcopy as dc
from scipy.interpolate import interp1d
from configparser import ConfigParser
import os, log


# ---------------------------------------------------------------------------------------------------------------------
def start(configfile):
    """
    Flag cosmic ray affected or bad pixel region values and correct those affected (here, "affected pixels" is a 
    collective term for cosmic ray affected and bad pixels) regions by replacing median values or by generating 
    simulated data from interpolated values.  If the pixel windows to replace are at the ends of the spectra, the 
    pixels are simply replaced by the fixed data values succeeding (preceeding) the maximum (minimum) data value of the
    pixel to be replaced at the blue (red) end of the spectra.
    
    In a window of 10 pixels, if there are less than 5 bad pixels, the median value of the window is replaced for all 
    bad pixels; otherwise, the windows are interpolated by the input interpolation method; then, simulated data values 
    are generated by random selection from a gaussian distribution of data values with statistical errors calculated 
    from mock data generated in the affected regions.  Currently, the only interpolation method applicable is "linear",
    which is also the default method.

    INPUTS:
        - data_path - absolute path to the directory where the data are located; string
        - spectra_filenames - filenames of the input spectra; string (of strings separated by commas and no spaces).  
                              These must be ASCII files containing 3 columns: pixels or wavelength, counts or flux, and 
                              error in counts or flux.
        - exclude_spectra - spectra numbers to be excluded from applying affected pixel corrections; string (of ints 
                            separated by commas and no spaces).  Default is an empty string.
        - median_width - +/-"window" about the pixel to be replaced by a median value; float.  Default is 5.
        - interpol_method - interpolation method for affected regions of more than 10 pixels; string.  Currently, the 
                            only option available is "linear".  Default is "linear".
        - interpol_width - +/-"window" about the pixel region to be replaced by interpolated values; float.  Default is
                           25.
        - interactive - if True, spectra are displayed at all intermediate stages of the correction process for visual
                        inspection; boolean.  Default is "True".
        - output_spectra_filename_suffix - suffix of the affected-pixel-corrected spectra filenames; string.  Default 
                                           is "_p".

    OUTPUTS:
        - ASCII files containing columns: x quantity [pixels], y quantity (same units as input spectra), and error in y 
          quantity (same units as input spectra)
        - ASCII files containing flag status of the spectra containing columns: x quantity [pixels] and flag status
    """
    logger = log.getLogger('correctAffectedPixels.start')

    logger.info('##############################################################################################')
    logger.info('#                                                                                            #')
    logger.info('#          START -- Correct for cosmic ray affected or bad pixel regions in spectra          #')
    logger.info('#                                                                                            #')
    logger.info('##############################################################################################\n')


    ################################################################################# 
    ##                                                                             ##
    ##          START -- Correct for Affected Pixel Regions General Setup          ##
    ##                                                                             ##
    #################################################################################


    # Print absolute path to the current working directory
    working_dir_path = os.getcwd()
    logger.info('Current working directory: %s', working_dir_path)

    # Import config parameters
    logger.info('Importing configuration parameters from %s.\n', configfile)
    config = ConfigParser()
    config.optionxform = str  ## make options case-sensitive
    config.read(configfile)
    
    # Read correctAffectedPixels specific config
    data_path = config.get('correctAffectedPixels','data_path')
    spectra_filenames = config.get('correctAffectedPixels','spectra_filenames')
    exclude_spectra = config.get('correctAffectedPixels','exclude_spectra')
    if not exclude_spectra:
        exclude_spectra = []  ## define an empty list
    else:
        exclude_spectra = [int(x) for x in exclude_spectra.split(',')]  ## convert comma-separated string of spectra  
                                                                        ## numbers into a list of ints
    median_width = config.getfloat('correctAffectedPixels','median_width')
    interpol_method = config.get('correctAffectedPixels','interpol_method')
    interpol_width = config.getfloat('correctAffectedPixels','interpol_width')
    interactive = config.getboolean('correctAffectedPixels','interactive')
    output_spectra_filename_suffix = config.get('correctAffectedPixels','output_spectra_filename_suffix')


    # Check if the path to the data directory provided by the user
    if not data_path:
        logger.error('#############################################################################################')
        logger.error('#############################################################################################')
        logger.error('#                                                                                           #')
        logger.error('#          ERROR in correctAffectedPixels: Absolute path to the data directory not          #')
        logger.error('#                             available.  Exiting script.                                   #')
        logger.error('#                                                                                           #')
        logger.error('#############################################################################################')
        logger.error('#############################################################################################\n')
        raise SystemExit
    else:
        logger.info('Absolute path to the data directory available.')
        logger.info('Data directory: %s', data_path)


    # Check if spectra provided by the user
    if not spectra_filenames:
        logger.error('############################################################################################')
        logger.error('############################################################################################')
        logger.error('#                                                                                          #')
        logger.error('#          ERROR in correctAffectedPixels: Spectra not detected.  Exiting script.          #')
        logger.error('#                                                                                          #')
        logger.error('############################################################################################')
        logger.error('############################################################################################\n')      
        raise SystemExit
    else:
        logger.info('Spectra detected.')
        spectra_filenames = [x for x in spectra_filenames.split(',')]  ## convert comma-separated string of filenames 
                                                                       ## into a list of strings
        logger.info('Spectra: %s', spectra_filenames)

    # Check if spectra available in the data directory
    spectra_not_available_ctr = 0

    for filename in spectra_filenames:
        filepath = data_path + '/' + filename
        if not os.path.exists(filepath):
            logger.info('Spectrum not available: %s', filepath)
            spectra_not_available_ctr += 1
    
    if spectra_not_available_ctr > 0:
        logger.error('#####################################################################################')
        logger.error('#####################################################################################')
        logger.error('#                                                                                   #')
        logger.error('#          ERROR in correctAffectedPixels: %s spectra not available in the          #', \
            spectra_not_available_ctr)
        logger.error('#                           data directory.  Exiting script.                        #')
        logger.error('#                                                                                   #')
        logger.error('#####################################################################################')
        logger.error('#####################################################################################\n')
        raise SystemExit
    
    else:
        logger.info('All spectra avialable.')

    
    # Check if parameters for correcting affected pixels provided by the user
    if not median_width:
        logger.warning('##########################################################################################')
        logger.warning('##########################################################################################')
        logger.warning('#                                                                                        #')
        logger.warning('#          WARNING in correctAffectedPixels: Width for calculating median value          #')
        logger.warning('#                                    not detected.                                       #')
        logger.warning('#                                                                                        #')
        logger.warning('##########################################################################################')
        logger.warning('##########################################################################################\n')
        logger.info('Setting the width for calculating median value to the default "5".')
        median_width = 5.
    else:
        logger.info('Width for calculating median value detected.')
        logger.info('Width for calculating median value: %s', median_width)

    if not interpol_method:
        logger.warning('##########################################################################################')
        logger.warning('##########################################################################################')
        logger.warning('#                                                                                        #')
        logger.warning('#          WARNING in correctAffectedPixels: Interpolation method not detected.          #')
        logger.warning('#                                                                                        #')
        logger.warning('##########################################################################################')
        logger.warning('##########################################################################################\n')
        logger.info('Setting the interpolation method to the default to the default "linear".')
        interpol_method = 'linear'
    
    elif interpol_method == 'linear':
        logger.info('Interpolation method detected.')
        logger.info('Interpolation method: %s', interpol_method)
    
    else:
        logger.warning('#############################################################################')
        logger.warning('#############################################################################')
        logger.warning('#                                                                           #')
        logger.warning('#          WARNING in correctAffectedPixels: Invalid interpolation          #')
        logger.warning('#                             method detected.                              #')
        logger.warning('#                                                                           #')
        logger.warning('#############################################################################')
        logger.warning('#############################################################################\n')
        logger.info('Setting the interpolation method to the default to the default "linear".')
        interpol_method = 'linear'

    if not interpol_width:
        logger.warning('###############################################################################')
        logger.warning('###############################################################################')
        logger.warning('#                                                                             #')
        logger.warning('#          WARNING in correctAffectedPixels: Width for interpolation          #')
        logger.warning('#                                not detected.                                #')
        logger.warning('#                                                                             #')
        logger.warning('###############################################################################')
        logger.warning('###############################################################################\n')
        logger.info('Setting the width for interpolation to the default "25".')
        interpol_width = 25.
    else:
        logger.info('Width for interpolation detected.')
        logger.info('Width for interpolation: %s', interpol_width)
    

    # Check if output filename suffix provided by the user
    if not output_spectra_filename_suffix:
        logger.warning('##############################################################################')
        logger.warning('##############################################################################')
        logger.warning('#                                                                            #')
        logger.warning('#          WARNING in correctAffectedPixels: Output filename suffix          #')
        logger.warning('#                               not detected.                                #')
        logger.warning('#                                                                            #')
        logger.warning('##############################################################################')
        logger.warning('##############################################################################\n')
        logger.info('Setting the output filename suffix to the default "_p".\n')
        output_spectra_filename_suffix = '_p'
    else:
        logger.info('Output filename suffix detected.')
        logger.info('Output filename suffix: %s\n', output_spectra_filename_suffix)


    #################################################################################### 
    ##                                                                                ##
    ##          COMPLETE -- Correct for Affected Pixel Regions General Setup          ##
    ##                                                                                ##
    ####################################################################################


    # Loop through all spectra
    for i in range(len(spectra_filenames)):
        spectrum_filename = data_path + '/' + spectra_filenames[i]
        logger.info('Working on spectrum %s: %s', i+1, spectrum_filename)


        # If spectra are not excluded, correction is performed; else, correction is skipped
        if i+1 not in exclude_spectra:
            logger.info('Spectrum %s is not excluded.  Proceeding with correcting for affected pixels...', i+1)


            # Load spectrum
            spectrum = ascii.read(spectrum_filename)
            x_qty = spectrum['col1']  ## x quantity
            y_qty = spectrum['col2']  ## y quantity
            error = spectrum['col3']  ## error in y quantity
        
            pixels = np.arange(1, len(y_qty) + 1, 1)  ## define an array of pixels equal in length to the y quantity
                                                      ## array
            # NOTE: Pixel array is defined instead of simply using the x array (although wavelength or pixels) from the 
            # input spectrum as whole pixel numbers will allow easy selection of the affected pixel windows to be 
            # corrected.


            # Plot original spectrum to allow for noting down affected pixel windows to be corrected
            plot_title = spectrum_filename[spectrum_filename.rfind('/')+1:] + ': Before affected pixels correction'
            plt.title(plot_title, fontsize=16)  ## plot title
            plt.xlabel('Pixels', fontsize=16)  ## label X axis
            plt.ylabel('Counts or count rate', fontsize=16)  ## label Y axis

            plt.plot(pixels, y_qty, color='k', marker='o')  ## plot y quantity
            plt.fill_between(pixels, y_qty - error, y_qty + error, color='gray', alpha=0.5)  ## plot error in y 
                                                                                             ## quantity
            
            plt.minorticks_on()
            plt.tick_params(axis='both', which='both', top=True, right=True, labelsize=16)  ## assign axes label size

            logger.info('Note down the affected or bad data pixel numbers to be replaced for the spectrum ' + \
                '(displayed in a separate window).')

            plt.show()
        

            # Ask user to input affected pixel windows to replace
            windows_to_replace = input('Enter the affected or bad data pixel windows (with integer pixel bounds ' + \
                'of a window separated by colons, and multiple windows separated by commas, with no spaces; e.g., ' + \
                'for a window use 3115:3127, and for an individual pixel use 1290:1290) to be replaced: ')
            
            if windows_to_replace:
                # If user input available, parse the input values
                logger.info('User input for affected pixels to replace available.  Proceding further with ' + \
                    'correcting for affected pixels...')
                windows_to_replace = windows_to_replace.split(',')
                windows_to_replace_lb = np.array([x.split(':')[0] for x in windows_to_replace]).astype(int) ## stores
                                                                        ## lower bounds of all windows to be replaced
                windows_to_replace_ub = np.array([x.split(':')[1] for x in windows_to_replace]).astype(int)  ## stores 
                                                                         ## upper bounds of all windows to be replaced
            else:
                # If user input not available, warn the user
                logger.warning('###############################################################################')
                logger.warning('###############################################################################')
                logger.warning('#                                                                             #')
                logger.warning('#          WARNING in correctAffectedPixels: User input for affected          #')
                logger.warning('#                  pixels windows to replace not available.                   #')
                logger.warning('#                                                                             #')
                logger.warning('###############################################################################')
                logger.warning('###############################################################################\n')
                logger.info('Skipping correcting for affected pixels.\n')
                continue

            pixels_to_replace = []  ## stores individual pixels to be replaced
            for i in range(len(windows_to_replace)):                
                if (windows_to_replace_lb[i] < pixels[0]) or (windows_to_replace_ub[i] > pixels[-1]):
                    logger.error('###########################################################################')
                    logger.error('###########################################################################')
                    logger.error('#                                                                         #')
                    logger.error('#          ERROR in correctAffectedPixels: Invalid window bounds          #')
                    logger.error('#           detected for pixels to be replaced.  Exiting script.          #')
                    logger.error('#                                                                         #')
                    logger.error('###########################################################################')
                    logger.error('###########################################################################\n')
                    raise SystemExit
                
                elif windows_to_replace_lb[i] == windows_to_replace_ub[i]:
                    pixels_to_replace.append(windows_to_replace_lb[i])
                
                elif windows_to_replace_ub[i] > windows_to_replace_lb[i]:
                    for j in range(windows_to_replace_lb[i], windows_to_replace_ub[i] + 1):
                        pixels_to_replace.append(j)
                
                elif windows_to_replace_lb[i] > windows_to_replace_ub[i]:
                    logger.error('############################################################################')
                    logger.error('############################################################################')
                    logger.error('#                                                                          #')
                    logger.error('#          ERROR in correctAffectedPixels: Reversed window bounds          #')
                    logger.error('#             detected to be replaced where the upper bound is             #')
                    logger.error('#              smaller than the lower bound.  Exiting script.              #')
                    logger.error('#                                                                          #')
                    logger.error('############################################################################')
                    logger.error('############################################################################\n')
                    raise SystemExit
                
                else:
                    pass

            
            # Assign flag status to individual pixels in the spectrum
            logger.info('Assigning flag status to individual pixels (1 for affected pixels to be replaced and 0 ' + \
                'for unaffected pixels).')

            flag_status_filename_1 = spectrum_filename[spectrum_filename.rfind('/')+1:]
            if flag_status_filename_1.find('_') == -1:
                flag_status_filename = flag_status_filename_1[:flag_status_filename_1.rfind('.')] + '_flags.dat'
            else:
                flag_status_filename = flag_status_filename_1[:flag_status_filename_1.find('_')] + '_flags.dat'
            flag_status_path = data_path + '/' + flag_status_filename
            
            # Check if flag status file already exists
            if os.path.exists(flag_status_path):
                # If yes, append flag status of the spectrum to the file
                logger.info('Flag status file already exits.')
                logger.info('Appending the existing flag status file.')

                flags = ascii.read(flag_status_path)
                x_qty_flags = flags['col1']  ## flags x quantity
                y_qty_flags = flags['col2']  ## flags y quantity
                
                flags_dict = {}  ## organizes the flag status in a dictionary
                for j in range(len(x_qty_flags)):
                    flags_dict[x_qty_flags[j]] = y_qty_flags[j]

                for j in pixels_to_replace:
                    flags_dict[j] = 1  ## assign flag status 1 for affected pixels to be replaced

                flags_dict_keys = sorted(flags_dict)
                flag_status = [flags_dict[k] for k in flags_dict_keys]

                np.savetxt(flag_status_path, np.c_[flags_dict_keys, flag_status]); \
                    logger.info('Saved an ASCII file named %s.', flag_status_path)
            
            else:
                # If no, save flag status of the spectrum in an ASCII file
                logger.info('Flag status file does not exit.')
                logger.info('Generating new flag status file.')

                flag_status = []  ## stores flag status of individual pixels
                
                for j in range(len(pixels)):
                    if pixels[j] in pixels_to_replace:
                        flag_status.append(1)
                    
                    elif pixels[j] not in pixels_to_replace:
                        flag_status.append(0)  ## assign flag status 0 for unaffected pixels to be replaced
                    
                    else:
                        logger.error('##########################################################################')
                        logger.error('##########################################################################')
                        logger.error('#                                                                        #')
                        logger.error('#          ERROR in correctAffectedPixels: Invalid pixel number          #')
                        logger.error('#               detected to be replaced.  Exiting script.                #')
                        logger.error('#                                                                        #')
                        logger.error('##########################################################################')
                        logger.error('##########################################################################\n')
                        raise SystemExit

                np.savetxt(flag_status_path, np.c_[pixels, flag_status]); \
                    logger.info('Saved an ASCII file named %s.', flag_status_path)


            # Replace affected pixels in the spectrum
            logger.info('Replacing affected pixels in the spectrum.')
            
            fixed_replace_blue_end = []  ## stores the pixels to be replaced by fixed values at the blue end of the 
                                         ## spectrum (shorter wavelength end)
            fixed_replace_red_end = []  ## stores the pixels to be replaced by fixed values at the red end of the 
                                        ## spectrum (longer wavelength end)
            median_replace = []  ## stores the pixels to be replaced by median values
            interpol_replace = []  ## stores the lists of pixels to be replaced by interpolated values
            
            for i in range(len(windows_to_replace)):
                if windows_to_replace_lb[i] == pixels[0]:
                    # Store pixel values to be replaced by fixed values when affected pixel window is at the lower end 
                    # of the spectrum
                    for j in range(windows_to_replace_lb[i], windows_to_replace_ub[i] + 1):
                        fixed_replace_blue_end.append(j)
                
                elif windows_to_replace_ub[i] == pixels[-1]:
                    # Store pixel values to be replaced by fixed values when affected pixel window is at the upper end 
                    # of the spectrum
                    for j in range(windows_to_replace_lb[i], windows_to_replace_ub[i] + 1):
                        fixed_replace_red_end.append(j)
                
                elif (windows_to_replace_ub[i] - windows_to_replace_lb[i]) < 5:
                    # Store pixel values to be replaced by median values when affected pixel window is less than 5 
                    # pixels
                    for j in range(windows_to_replace_lb[i], windows_to_replace_ub[i] + 1):
                        median_replace.append(j)
                
                elif (windows_to_replace_ub[i] - windows_to_replace_lb[i]) >= 5:
                    # Store pixel values to be replaced by interpolated values when affected pixel window is greater
                    # than 5 pixels
                    interpol_replace.append(list(np.arange(windows_to_replace_lb[i], windows_to_replace_ub[i] + 1, 1)))
                
                else:
                    pass
            
            y_qty_pcorr_1 = dc(y_qty)  ## create a deep copy of the y quantity array to store the corrected pixel 
                                       ## values
            error_pcorr_1 = dc(error)  ## create a deep copy of the error array to store the corrected pixel values
            # NOTE: A deep copy allows to maintain the orginal list or array separate from the new list or array so 
            # that when the new list or array is edited, the original does not get appended.
            

            # Replace by fixed values
            # At the blue end
            if len(fixed_replace_blue_end) != 0:
                fixed_index_blue_end = np.where(pixels == np.max(fixed_replace_blue_end) + 1)  ## next index to the
                                                 ## index of the maximum pixel value to be replaced at the blue end
                fixed_blue_end_y_qty = y_qty[fixed_index_blue_end]  ## y quantity at the "fixed" index set at the blue
                                                                    ## end
                fixed_blue_end_error = error[fixed_index_blue_end]  ## error at the "fixed" index set at the blue end
                
                logger.info('Replacing fixed values for affected pixels at the blue end of the spectrum (shorter ' + \
                    'wavelength end).')
                for i in range(len(fixed_replace_blue_end)):
                    y_qty_pcorr_1[fixed_replace_blue_end[i]-1] = fixed_blue_end_y_qty  ## append the fixed replaced 
                                                                 ## pixels in the deep copy of the y quantity array
                                                                 ## created to store the corrected pixel values
                    error_pcorr_1[fixed_replace_blue_end[i]-1] = fixed_blue_end_error  ## append the fixed replaced
                                                              ## pixels in the deep copy of the error array created 
                                                              ## to store the corrected pixel values
            
            else:
                logger.info('No pixel values to replace at the blue end of the spectrum (shorter wavelength end).')
            
            # At the red end
            if len(fixed_replace_red_end) != 0:
                fixed_index_red_end = np.where(pixels == np.min(fixed_replace_red_end) - 1)  ## previous index to the
                                                   ## index of the minimum pixel value to be replaced at the blue end
                fixed_red_end_y_qty = y_qty[fixed_index_red_end]
                fixed_red_end_error = error[fixed_index_red_end]
                
                logger.info('Replacing fixed values for affected pixels at the red end of the spectrum (longer ' + \
                    'wavelength end).')
                for i in range(len(fixed_replace_red_end)):
                    y_qty_pcorr_1[fixed_replace_red_end[i]-1] = fixed_red_end_y_qty
                    error_pcorr_1[fixed_replace_red_end[i]-1] = fixed_red_end_error
            
            else:
                logger.info('No pixel values to replace at the red end of the spectrum (longer wavelength end).')


            # Replace by median values
            median_replaced_pixels_y_qty = []  ## stores the median values of y quantity calculated over a range given
                                               ## by "median_width" about the pixel to be replaced
            median_replaced_pixels_error = []  ## stores the median values of error calculated over a range given by 
                                               ## "median_width" about the pixel to be replaced

            if len(median_replace) != 0:
                logger.info('Replacing median values for affected pixels.')
                
                for i in range(len(median_replace)):
                    median_indices = list(np.arange(median_replace[i] - median_width - 1, \
                        median_replace[i] + median_width, 1).astype(int))  ## stores the indices of the range of pixels 
                                                                           ## to be used to calculate the median
                    
                    median_range_y_qty = [y_qty[j] for j in median_indices]  ## stores the y quantity values over the 
                                                                   ## range of pixels to be replaced by median values
                    median_replaced_pixels_y_qty.append(stats.median(median_range_y_qty))
                    y_qty_pcorr_1[median_replace[i]-1] = median_replaced_pixels_y_qty[i]  ## append the median replaced 
                                                             ## pixels in the deep copy of the y quantity array created 
                                                             ## to store the corrected pixel values

                    median_range_error = [error[j] for j in median_indices]  ## stores the error values over the range
                                                                          ## of pixels to be replaced by median values
                    median_replaced_pixels_error.append(stats.median(median_range_error))
                    error_pcorr_1[median_replace[i]-1] = median_replaced_pixels_error[i]  ## append the median replaced 
                                                             ## pixels in the deep copy of the y quantity array created 
                                                             ## to store the corrected pixel values
            
            else:
                logger.info('No pixel values to replace by median values.')

            
            # Replace by interpolated values
            interpol_replaced_pixels_y_qty = []  ## stores the interpolated y quantity computed from the range of 
                                                 ## pixels given by interpol_width on both sides of the affected region
                                                 ## to be replaced
            replaced_pixels_error = []  ## stores the median values of error calculated over a range given by 
                                        ## interpol_width on both sides of the affected region to be replaced

            for i in range(len(interpol_replace)):
                interpol_replace_indices = [j-1 for j in interpol_replace[i]]  ## stores the indices of the range of 
                                                                     ## pixels to be replaced by interpolated values 
                                                                     ## for y quantity and median for error
                interpol_indices = list(np.arange(interpol_replace[i][0] - interpol_width - 1, \
                    interpol_replace[i][0] - 1, 1).astype(int)) + list(np.arange(interpol_replace[i][-1] + 1, \
                    interpol_replace[i][-1] + interpol_width + 1, 1).astype(int))  ## stores the indices of the range
                                                                                   ## of pixels to be used to compute 
                                                                                   ## interpolation functions for flux 
                                                                                   ## density and median for error
            
                interpol_range_x = [pixels[j] for j in interpol_indices]  ## pixels used as the x range to compute the
                                                                          ## y quantity interpolation function
                interpol_range_y = [y_qty[j] for j in interpol_indices]  ## y quantity values used as the y 
                                                                                ## range to compute the y quantity
                                                                                ## interpolation function
                interpol_range_x_new = list(np.arange(interpol_replace[i][0], interpol_replace[i][-1], 0.1))  ## pixels
                                                                                   ## used as x range for interpolation

                interpol_range_y_new_mock_points = np.zeros((1000, len(interpol_range_x_new)))  ## stores mock y new 
                                                                                 ## ranges geenrated by interpolation

                if interpol_method == 'linear':
                    # Perform linear interpolation
                    logger.info('Performing linear interpolation.')
                    interpol_replace_func_y = interp1d(interpol_range_x, interpol_range_y, kind='linear')  ## compute 
                                                                             ## the y quantity interpolation function
                    interpol_range_y_new = interpol_replace_func_y(interpol_range_x_new)  ## compute interpolated flux 
                                                                                        ## density for affected pixels
                    
                    # Compute statistical uncertainties for the interpolated y quantities
                    for iteration in range(1000):
                        interpol_range_y_mock = [gauss(y_qty[j], error[j]) for j in interpol_indices]  ## randomly 
                                                          ## select y quantity values from a gaussian distribution
                        
                        interpol_replace_func_y_mock = interp1d(interpol_range_x, interpol_range_y_mock, kind='linear')
                        interpol_range_y_new_mock = interpol_replace_func_y_mock(interpol_range_x_new)

                        interpol_range_y_new_mock_points[iteration,:] = interpol_range_y_new_mock

                else:
                    logger.warning('#############################################################################')
                    logger.warning('#############################################################################')
                    logger.warning('#                                                                           #')
                    logger.warning('#          WARNING in correctAffectedPixels: Invalid interpolation          #')
                    logger.warning('#                             method detected.                              #')
                    logger.warning('#                                                                           #')
                    logger.warning('#############################################################################')
                    logger.warning('#############################################################################\n')
                    logger.info('Setting interpolation method to the default "linear".')
                    interpol_method = 'linear'

                    logger.info('Performing linear interpolation.')
                    interpol_replace_func_y = interp1d(interpol_range_x, interpol_range_y, kind='linear')                  
                    interpol_range_y_new = interpol_replace_func_y(interpol_range_x_new)

                    for iteration in range(1000):
                        interpol_range_y_mock = [gauss(y_qty[j], error[j]) for j in interpol_indices]  
                        
                        interpol_replace_func_y_mock = interp1d(interpol_range_x, interpol_range_y_mock, kind='linear')
                        interpol_range_y_new_mock = interpol_replace_func_y_mock(interpol_range_x_new)

                        interpol_range_y_new_mock_points[iteration,:] = interpol_range_y_new_mock

                range_y_err_new = [stats.stdev(interpol_range_y_new_mock_points[:,j]) \
                    for j in range(len(interpol_range_x_new))]  ## calculate standard deviation of the mock
                                                                ## interpolated y quantity values as error in the 
                                                                ## interpolated y quantity values
                
                interpol_replaced_pixels_y_qty.append(interpol_range_y_new)
                replaced_pixels_error.append(range_y_err_new)
                
                for j in range(len(interpol_replace_indices)):
                    y_qty_pcorr_1[interpol_replace_indices[j]] = interpol_replaced_pixels_y_qty[i][j]  ## append the 
                                                  ## interpolated replaced pixels in the deep copy of the y quantity
                                                  ## array created to store the corrected pixel values
                    error_pcorr_1[interpol_replace_indices[j]] = replaced_pixels_error[i][j]  ## append the statistical 
                                                       ## errors in the interpolated y quantity values in the deep copy
                                                       ## of the error array created for corrected pixel values

            
            if interactive:
                # Plot spectra with and without affected pixel correction
                fig = plt.figure()
                ax = fig.add_subplot(111)
                
                plot_title = spectrum_filename[spectrum_filename.rfind('/')+1:] + ': Affected pixels replaced by ' + \
                    'interpolated data'
                plt.title(plot_title, fontsize=16)
                ax.set_xlabel('Pixels', fontsize=16)
                ax.set_ylabel('Counts or count rate', fontsize=16)
                
                for i in range(len(windows_to_replace)):  ## plot a shaded region for the the affected pixel area where
                                                          ## correction was applied
                    if i == 0:
                        ax.axvspan(windows_to_replace_lb[i], windows_to_replace_ub[i], facecolor='#F1CD46', alpha=0.5,\
                            label='Affected pixel regions')
                    else:
                        ax.axvspan(windows_to_replace_lb[i], windows_to_replace_ub[i], facecolor='#F1CD46', alpha=0.5)
                
                ax.plot(pixels, y_qty, color='k', ls='-', lw=2, label='Raw')
                ax.fill_between(pixels, y_qty - error, y_qty + error, color='gray', alpha=0.5)
                
                ax.plot(pixels, y_qty_pcorr_1, color='r', ls='-', lw=2, label='Interpolated')  ## plot corrected y 
                                                                                               ## quantity
                ax.fill_between(pixels, y_qty_pcorr_1 - error_pcorr_1, y_qty_pcorr_1 + error_pcorr_1, color='#FF7474',\
                    alpha=0.5)  ## plot corrected error

                fig.legend(bbox_to_anchor=(0.5, 0.4, 0.5, 0.5), fontsize=16)  ## assign legend
                
                ax.minorticks_on()
                ax.tick_params(axis='both', which='both', top=True, right=True, labelsize=16)

                fig.subplots_adjust(left=0.08, right=0.76, bottom=0.1, top=0.90)  ## adjust plot position
                
                plt.show()
            
            else:
                pass
            

            # Generate simulated values for corrected, affected pixel regions by random selection from a gaussian
            # distribution of data values with statistical errors in the affected regions
            logger.info('Generating simulated values for corrected, affected pixel regions by random selection ' + \
                'from a gaussian distribution of data values with statistical errors in the affected regions.')
            
            y_qty_pcorr_2 = []  ## stores the corrected and simulated y quantity values for affected pixels
            error_pcorr_2 = []  ## stores the corrected and simulated error values for affected pixels

            for i in range(len(pixels)):
                # Simulate data except for the end pixels
                if flag_status[i] == 1:
                    if (pixels[i] in fixed_replace_blue_end) or (pixels[i] in fixed_replace_red_end):
                        # Append values from the first step in correction
                        y_qty_pcorr_2.append(y_qty_pcorr_1[i])
                        error_pcorr_2.append(error_pcorr_1[i])
                    else:
                        y_qty_pcorr_2.append(gauss(y_qty_pcorr_1[i], error_pcorr_1[i]))  ## randomly select y quantity 
                                                                       ## values from a gaussian distribution assuming
                                                                       ## twice the error in the region
                        error_pcorr_2.append(2 * error_pcorr_1[i])  ## assign twice the error in the region as the 
                                                                    ## error in the simulated y quantity values for 
                                                                    ## affected pixels
                else:
                    y_qty_pcorr_2.append(y_qty_pcorr_1[i])
                    error_pcorr_2.append(error_pcorr_1[i])
            

            if interactive:
                # Plot spectra with and without affected pixel correction, and simulated data for affected pixels
                fig = plt.figure()
                ax = fig.add_subplot(111)

                plot_title = spectrum_filename[spectrum_filename.rfind('/')+1:] + ': Affected pixels replaced by ' + \
                    'simulated data'
                plt.title(plot_title, fontsize=16)
                ax.set_xlabel('Pixels', fontsize=16)
                ax.set_ylabel('Counts or count rate', fontsize=16)
                
                for i in range(len(windows_to_replace)):
                    if i == 0:
                        ax.axvspan(windows_to_replace_lb[i], windows_to_replace_ub[i], facecolor='#F1CD46', alpha=0.5,\
                            label='Affected pixel regions')
                    else:
                        ax.axvspan(windows_to_replace_lb[i], windows_to_replace_ub[i], facecolor='#F1CD46', alpha=0.5)
                
                ax.plot(pixels, y_qty, color='k', ls='-', lw=2, label='Raw')
                ax.fill_between(pixels, y_qty - error, y_qty + error, color='gray', alpha=0.5)
                
                ax.plot(pixels, y_qty_pcorr_1, color='r', ls='-', lw=2, label='Interpolated')
                ax.fill_between(pixels, y_qty_pcorr_1 - error_pcorr_1, y_qty_pcorr_1 + error_pcorr_1, color='#FF7474',\
                    alpha=0.5)

                ax.plot(pixels, y_qty_pcorr_2, color='#0027FF', ls='--', lw=2, label='Simulated')  ## plot corrected y 
                                                                                       ## quantity with simulated data
                ax.fill_between(pixels, np.array(y_qty_pcorr_2) - np.array(error_pcorr_2), np.array(y_qty_pcorr_2) + \
                    np.array(error_pcorr_2), color='#778BFF', alpha=0.5)  ## plot corrected error with simulated data

                fig.legend(bbox_to_anchor=(0.5, 0.4, 0.5, 0.5), fontsize=16)
                
                ax.minorticks_on()
                ax.tick_params(axis='both', which='both', top=True, right=True, labelsize=16)
                
                fig.subplots_adjust(left=0.08, right=0.76, bottom=0.1, top=0.90)

                plt.show()
            
            else:
                pass
            

            # Save spectrum corrected for affected pixels in an ASCII file
            spectrum_filename_pcorr = spectrum_filename[:spectrum_filename.rfind('.')] + \
                output_spectra_filename_suffix + '.dat'
            np.savetxt(spectrum_filename_pcorr, np.c_[pixels, y_qty_pcorr_2, error_pcorr_2]); \
                logger.info('Saved an ASCII file named %s.', spectrum_filename_pcorr)

        else:
            
            logger.info('Spectrum %s is excluded.  Skipping correcting for affected pixels.\n', i+1)


    logger.info('#################################################################################################')
    logger.info('#                                                                                               #')
    logger.info('#          COMPLETE -- Correct for cosmic ray affected or bad pixel regions in spectra          #')
    logger.info('#                                                                                               #')
    logger.info('#################################################################################################\n')

    return


# ---------------------------------------------------------------------------------------------------------------------
if __name__ == '__main__':
    # Set log file
    log.configure('correctAffectedPixels.log', filelevel='INFO', screenlevel='DEBUG')

    start('prepdataps.cfg')
    